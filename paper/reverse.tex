  \begin{figure*}[t]
    \begin{minipage}{0.3\textwidth}
    \vspace{-2em}
    \centering
    \begin{tikzpicture}
   \matrix[square matrix]
   {
      \tiny S,\textbf{SE} & S & SW   & \tiny SW,SE & SE & S & \tiny S,\textbf{SW}  \\ 
      \tiny S,\textbf{SE} & \textbf{S} & W    & \tiny \textbf{W},E & E & \textbf{S} & \tiny S,\textbf{SW}  \\ 
      \textbf{SW} & \textbf{S} & |[fill=black]|  & |[fill=black]|  & |[fill=black]|   & \textbf{S} & \textbf{SE}  \\ 
      \textbf{E} & \textbf{E} & \textbf{E}      & |[fill=yellow]| $t$  & \textbf{W} & \textbf{W} & \textbf{W}  \\ 
      \tiny E,\textbf{NE} & \tiny E,\textbf{NE} & \textbf{NE} & \textbf{N}  & \textbf{NW} & \tiny W,\textbf{NW} & \tiny W,\textbf{NW} \\
   };
    \end{tikzpicture}
    \caption{Optimal first moves from each grid cell to the cell marked $t$. Moves in bold agree with the default heuristic.}
    \label{fig:r}
    \end{minipage}
    \hspace{2em}
  \begin{minipage}{0.3\textwidth}
    \centering
    \begin{tikzpicture}
   \matrix[square matrix]
   {
      |[fill=yellow]| $t$ & |[fill=black]| & S & \tiny S,SW & \tiny S,SW & SW \\
      \textbf{N} & |[fill=black]| & S & \tiny S,SW & SW    & \tiny W,SW \\
      \textbf{N} & |[fill=black]| & S & SW & \tiny W,SW    & \tiny W,SW \\
      \textbf{N} & \textbf{W} & W & W & W & W \\
   };
    \end{tikzpicture}
    \caption{Optimal first moves from each grid cell to the cell marked $t$. Moves in bold agree 
    with the default heuristic.}
    \label{fig:rh}
    \end{minipage}
    \hspace{2em}
  \begin{minipage}{0.3\textwidth}
  \vspace{-1.5em}
    \centering
    \begin{tikzpicture}
   \matrix[square matrix]
   {
%       \tiny \textbf{S},SE & \tiny S,SE & \tiny S,SE & S \\
%       SE & \tiny S,SE & \tiny S,SE & S \\
%       \tiny S,SE, \textbf{E} & \tiny S,SE & \tiny S,SE & S \\
      |[fill=black]| & SE &  \tiny S,SE & S \\ 
      |[fill=black]| & \tiny S,SE, \textbf{E} &  SE & S \\ 
      |[fill=black]| & |[fill=black]| & \tiny S,SE, \textbf{E} & S \\ 
      |[fill=black]| & |[fill=black]|& |[fill=black]| & \tiny \textbf{S},SW \\
      |[fill=yellow]| $t$ & \tiny \textbf{W},NW & \tiny \textbf{W},NW  & \tiny \textbf{W},NW \\  
   };
    \end{tikzpicture}
    \caption{Optimal first moves toward the grid cell $t$ with added illegal move symbols
    for cells adjacent to obstacles. 
    %when executed but which can be decoded. Moves in bold agree with the default heuristic.
    }
    \label{fig:rhh}
  \end{minipage}  
  \end{figure*}  


\section{Reverse Compressed Path Databases}
\label{sec:reverse}

Centroids can dramatically reduce the amount of time required to build
CPDs.  However, in many cases, the \emph{size} of centroid-based CPD 
is not much smaller than a full-size optimal CPD.
Figure~\ref{fig:fwd0-fwdc} shows compression improvement ratios for $\delta$
= $2,4,8,16,32,64$ on the set of maps from GPPC 2012 (a common
benchmark).  Notice that the median improvement ratio is $\approx$1.5,
even for $\delta = 64$.  What is happening?

%Even though the number of \emph{targets} is reducing substantially in Figure~\ref{fig:fwd0-fwdc} 
%the number of compressed strings $L(s)$ remains remains similar.
%as one per node $s$ in the graphs (all possible \emph{start} positions).  
%Even though the strings $L(s)$ only need to store information for a reduced set of targets, the centroids, they are not significantly shorter. 
In an optimal CPD many nodes which share the same first move can be grouped together
into a single run. 
In a centroid-based CPD, the number of nodes is much smaller but the nodes are dispersed.
That means two centroids which are adjacent in our column ordering might not share the same 
first move. In such cases each centroid forms a new run, but the \emph{number of runs} is
not significantly reduced. 
Another reason for which the usage of centroids often fails to significantly reduce the CPD size is that
full ``forward'' CPDs already achieve a good compression, for example, most of rows can be compressed into only a few runs,
thus further improvement is difficult.
In this section we propose {\em reverse CPDs}, an alternative method 
for storing first-move data which can improve the situation.

%A clear problem with the centroid idea for the usual
%forward CPDs is that is reduces only the number of targets and we need one string per start node.  This leads us to consider reverse CPDs.


%We will call a \emph{reverse Compressed Path Database} any data structure that implements the 
%$\textsf{FirstMove}(s,t)$ function in the opposite manner to a standard CPD.
In a forward (equiv.\ standard) CPD, each start node $s$ is associated with
a compressed string of symbols that together encode optimal first
moves toward any target $t$.  In a reverse CPD there exists a compressed
string of symbols for each target $t$ which also encodes an optimal first
move, this time from any node $s$ toward the node $t$.  

Reverse CPDs can be computed with only small adjustments to Dijkstra's
algorithm.  They are also compatible with recent space-saving improvements 
such as heuristic moves and proximity wildcards~\cite{icaps19b}.  
A potential drawback is that the first move data is now more dependent 
on the local topology around each $s$ than on the position of the target $t$.
%  \begin{figure}
%    \centering
%    \begin{tikzpicture}
%   \matrix[square matrix]
%   {
%      \tiny S,\textbf{SE} & S & SW   & \tiny SW,SE & SE & S & \tiny S,\textbf{SW}  \\ 
%      \tiny S,\textbf{SE} & \textbf{S} & W    & \tiny \textbf{W},E & E & \textbf{S} & \tiny S,\textbf{SW}  \\ 
%      \textbf{SW} & \textbf{S} & |[fill=black]|  & |[fill=black]|  & |[fill=black]|   & \textbf{S} & \textbf{SE}  \\ 
%      \textbf{E} & \textbf{E} & \textbf{E}      & |[fill=yellow]| $t$  & \textbf{W} & \textbf{W} & \textbf{W}  \\ 
%      \tiny E,\textbf{NE} & \tiny E,\textbf{NE} & \textbf{NE} & \textbf{N}  & \textbf{NW} & \tiny W,\textbf{NW} & \tiny W,\textbf{NW} \\
%   };
%    \end{tikzpicture}
%    \caption{The optimal first moves from each cell of the gridmap to the cell marked $t$. Moves in bold agree with the default move.}
%    \label{fig:r}
%  \end{figure}  
%
%
%
\begin{example}
Figure~\ref{fig:r} shows reverse first-move table which we compress to
1S 3SW 5SE 6S 10W 12E 13S 15SW 16S 21SE 22E 26W 29NE 32N 33NW, which is 15 runs.
Our encoding assumes a left-right-top-bottom column ordering.
Adding h-moves reduces this to 1S 3SW 5SE 6S 10W 12E 13\heur, which is 7 runs.
For comparison, in the forward direction the first-move table for source $t$ can 
be encoded with just a single run: 1\heur.
\end{example}

 
\subsection{Illegal Moves}
%Reverse CPDs are much larger than forward CPDs and part of this is the result of common patterns of behaviour. 

We can improve the run length encoding of reverse CPDs by also allowing
``illegal moves'' to be part of the set of possible moves: i.e., moves
to blocked cells, or cells which cannot appear on any optimal path from
$s$ to $t$.  In both cases illegal moves are useful if they can be 
unambiguously \emph{decoded} by some function to extract a correct 
optimal move.

\begin{example}
Figure~\ref{fig:rh} shows a reverse first-move table where
S moves appear as the only symbols of three nodes in column 3. 
These symbols force us to create one additional run per row. 
To improve compression we will store at each of these locations 
an additional symbol, SW, which can be used to reduce the database 
by three runs.
Although following this move produces an obstacle we can still
proceed if we detect the situation at runtime.
To decode the SW symbol we choose the closest move to SW which 
is legal: here, S. Our decoding function guarantees that any
returned move is an optimal first move.
\end{example}
%in this case we can detect the situation and \emph{decode} SW
%to compute S, which is the closest legal move.
%retrieved from the CPD to be S since this is the closest legal move from
%each of these positions.  If we do this the run length encoding for $t$
%can be reduced to 1SW 7N 9SW 13N 15SW 19N 20W.

  
%\begin{example}
%Consider the reverse CPD for the target $t$ shown in Figure~\ref{fig:rh}.
% The best encoding is 1S 6SW 7N 9S 11SW 13N 15S 16SW 19N 20W.   The encoding is hampered by the fact that each row has a transition from S to SW.
%  
%  Compare this to the forward CPD where $t$ is the start, which is a single entry 1S, since only one move is possible from $t$.
%\end{example} 


%  \begin{figure}
%    \centering
%    \begin{tikzpicture}
%   \matrix[square matrix]
%   {
%       \tiny \textbf{S},SE & \tiny S,SE & \tiny S,SE & S \\
%       SE & \tiny S,SE & \tiny S,SE & S \\
%       \tiny S,SE, \textbf{E} & \tiny S,SE & \tiny S,SE & S \\
%      |[fill=black]| & SE &  \tiny S,SE & S \\ 
%      |[fill=black]| & \tiny S,SE, \textbf{E} &  SE & S \\ 
%      |[fill=black]| & |[fill=black]| & \tiny S,SE, \textbf{E} & \textbf{S} \\ 
%      |[fill=black]| & |[fill=black]|& |[fill=black]| & \tiny S,\textbf{SW} \\
%      |[fill=yellow]| $t$ & \tiny \textbf{W},NW & \tiny \textbf{W},NW  & \tiny \textbf{W},NW \\  
%   };
%    \end{tikzpicture}
%    \caption{The optimal first moves from each cell of the gridmap to the cell marked $t$ including moves blocked by filled cells which decode to an optimal move. Moves in bold agree with the heuristic move.}
%    \label{fig:rhh}
%  \end{figure}  

\begin{example}
%Illegal moves are not limited to those moves which produce obstacles.
%They can also be valid moves that cannot possibly appear on the optimal
%path to the target $t$.
Consider the example in Figure~\ref{fig:rhh}. 
We show a reverse first-move table which already includes some illegal moves; i.e., those
that produce obstacles and which can be appropriately decoded.
%The best run-length encoding, for the order left-right-top-bottom, is 1S 5SE 8S 14SE 16S 19SE 20S 30W.   


Further compression here is hampered by the two tiles with SE-only moves.
Notice however that while the S move from each of these locations is valid
it is not \emph{helpful}.  
The only reason to apply move S from these positions is to reach the 
cell directly below and no other. 
If we extend our notion of ``illegality'' to prevent such S moves, 
we can add S to the set of symbols for the currently SE-only tiles. 
When extracted at runtime, the illegal move S can be decoded to SE. 
With this enhancement the table can compress into two runs: 1S 18W.
\end{example}
%\begin{example}
%  Consider the reverse CPD for the target $t$ shown in Figure~\ref{fig:rhh}
%  where we have included moves to blocked cells which decode to the correct move
%  (we don't consider moves off the map).
%  The best encoding is 1S 5SE 8S 14SE 16S 19SE 20S 30W.   
%  The encoding is hampered by the fact that each column has a SE only 
%  move which avoids moving next to an obstacle. The S move is not blocked but it
%  is not \emph{helpful}.  The only reason to move S from these positions 
%  is to reach the position directly below and no other. 
%  If we extend our notion of ``illegality'' to prevent these S moves we can then
%  add S as a possible move in these positions, and decode it to be SE. 
%  With this addition the best encoding is 1S 30W.
%\end{example}

\subsection{Preprocessing and Path Extraction}
Building a reverse CPD for target $t$ can be performed by a single
Dijsktra search from the target and recording for each cell $s$ all best
moves for reaching $t$.  Compression proceeds as usual.
In the experimental section, we will show that build times for reverse CPDs 
and forward CPDs using the same set of centroids $C$ are similar.

Algorithm~\ref{alg:cpdhd} gives a modified version of \textsf{FirstMove}($s$, $t$); i.e., 
the CPD first move extraction function which is here modified for reverse CPDs
and which decodes both ``illegal'' and h-moves. 
This algorithm extracts a first move $m$ as usual, and, if this move is not ``legal'', 
it finds the closest move that is legal and returns that instead.  
Function $legal(m,s,t)$ returns $\false$ if moving
in direction $m$ from $s$: (i) leads to a blocked square, or (ii) cuts a corner,
or (iii) moves to a position $m(s) \neq t$ where all successors are 
better reached directly from $s$.  In all other cases $legal(m,s,t)$ 
returns $\true$.
Function $closest(m,S)$ returns the closest move to $m$ in set $S$
breaking ties by moving clockwise, e.g., $closest(\mbox{SW}, \{\mbox{N}, \mbox{NE}, \mbox{E}\}) = \mbox{N}$
and $closest(\mbox{S}, \{\mbox{N}, \mbox{NE}, \mbox{E}\}) = \mbox{E}$.  Note that the notion of ``illegal''
moves does not make sense in a forward CPD, as we only ever consider 
legal moves and h-moves.

\begin{algorithm}[t]
%\textsf{CPDHD}($s$, $t$) \\
   {$m \gets$ \textsf{FirstMove}($s$,$t$) \\
     \If{$m = \heur$}
         {$m = F_x(s,t)$}
     \If{$\neg legal(m,s,t)$}    
         {\mbox{$m = closest(m,\{mv| mv\in MV,legal(mv,s,t)\})$}}
    \Return $m$
    }
\caption{The function \textsf{FirstMove}$^r$($s$, $t$) for reverse CPDs with h-moves and illegal moves.}
\label{alg:cpdhd}
\end{algorithm}

\subsection{Performance Advantages of Reverse CPDs}
In the experimental section we will show that reverse CPDs, in combination with
centroids and suitable values of $\delta$, can cut storage costs w.r.t.\
forward CPDs. 
In terms of runtime, reverse CPDs again have advantages w.r.t.\ forward CPDs.

The first runtime advantage is that path extraction is usually faster.
This is due to memory caching and can be understood as follows.
When extracting a path with reverse CPDs we require only a single compressed 
string: the one computed for the target $t$.
Once this string is loaded into CPU cache, it resides there throughout
the entirety of path extraction. %Reading data from CPU cache is very fast.
By comparison, forward CPDs require a different compressed string at each step
on the path to $t$ and extracting each new move incurs the possibility of a cache miss. 
In other words, reading data from CPU cache is very fast and loading data from main memory
is very slow. 
%After looking up the next move $m$ from the CPD for position $s$, forward CPDs require the use of a new CPD for start position $m(s)$ for the next step of path extraction.
%Hence we need to read in a new CPD string for every step in the path extraction.

The second runtime advantage is that we can extract the entire run 
from a reverse CPD rather than just a single move.
That means we can avoid additional extractions if the first move of next location $m(s)$ 
is compressed in the same run as $s$.
This behaviour is surprisingly frequent because of the column ordering. 
Figure~\ref{fig:access} shows the comparison of the number of lookups required to 
extract a path of a given number of steps.
%looking up times with increasing steps. 
For forward CPDs the number of extractions are always linear in the steps, 
while reverse CPDs require substantially fewer number of extractions.

