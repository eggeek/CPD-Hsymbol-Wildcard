\section{Compressed Path Databases}

Given a graph $G = (V,E)$ with vertices $V$ and edges $E$

The essence of a compressed path database is a data structure
that allows us to
quickly extract for any pairs of points $S$ and $T$
in the graph a
first move to take from $S$ in order to reach $T$ optimally.


A compressed path
database is an array of lists of rectangles, with up to 4 lists
for each node $n \in V$.
Building a compressed database requires
a series of iterations, one for each node $n$, as illustrated
in Algorithm~\ref{alg:cpd}.
Being independent, the iterations can
be run in parallel, with a speed-up linear in the number of
available processors. A slight modification of the Dijkstra
algorithm produces a so-called first-move table $T(n)$,
using $n$ as an origin point.
In a first-move table, all nodes $t$
reachable from $n$ are assigned a first-move label
that identifies all first moves from $n$
that start a shortest path towards $t$.


We restrict ourselves in the presentation to octile
grid graphs where the 8 possible moves from any position are
$N$, $S$, $E$, $W$, $NE$, $NW$, $SE$, and $SW$.
The ideas are generalizable to any graphs where ...

The compressed data base stores this information.
We assume a function \textsf{CPD}($s$,$t$) which returns a
next move from $s$ which is part of some optimal path to $t$.

\begin{algorithm}
  \caption{Building a CPD}
  \label{alg:cpd}
  \For{each $n \in V$}
      { $T(n) \gets \textsf{Dijkstra}(n)$ \\
        $L(n) \gets \textsf{Compress}(T(n))$ }
\end{algorithm}

After applying \textsf{Dijkstra} we have a table
$T(n)$ for node $n$ which for each node $t$
returns a list of all possible first moves
which lead to a shortest path to node $t$.
The compression algorithm uses run length encoding
to encode one correct move for each node $t$.

\begin{algorithm}
  \caption{Optimal Run Length Encoding of CPD}
  \label{alg:rle}
  $i \gets 0$ \\
  $t \gets 1$ \\
  $f \gets T(n)(t)$ \\
  $c \gets 1$ \\
  \While{$t < |N|$}
    { $t \gets t + 1$ \\
    $g \gets f \cap T(n)(t)$ \\
    \If{$g = \emptyset$}
       { \textrm{choose} $mv \in f$ \\
         $D[i] \gets (c, mv, t-1)$ \\
         $i \gets i + 1$ \\
         $g \gets T(n)(t)$ \\
         $c \gets 1$ }
       $f \gets g$
    }
    \textrm{choose} $mv \in f$ \\
    $D[i] \gets (c, mv, |N|)$ \\
    \Return $D$
\end{algorithm}
         
The decoding of the CPD uses binary search

\begin{algorithm}
  \caption{Decoding the Run Length Coding}
  $l \gets 0$ \\
  $li \gets 1$ \\
  $u \gets |D|$  \\
  \While{$l < u$}
        { $m \gets \lfloor \frac{l+u}{2} \rfloor$ \\
          $(c, mv, n) \gets D[m]$ \\
        \uIf{$t > n$}
           {$l \gets m$ \\
            $li \gets n$} 
        \uElseIf{$t < n \wedge t \geq li$}
            {\Return $mv$}
        \Else{$u \gets m$}
        }
\end{algorithm}

\begin{algorithm}
  \caption{Retrieving a path at runtime for an ($s,t)$ pair}
  \label{alg:retrieve}
  $n \gets s$ \\
  \While{$n \neq t$}
        {$e \gets$ \textsf{CPD}($n,t$) \\
         $n \gets \mbox{node after move~} e$
         }
\end{algorithm}


